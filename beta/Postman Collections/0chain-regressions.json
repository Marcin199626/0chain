{
  "info": {
    "_postman_id": "00a95861-247b-4d8f-bbd7-ddeadf919bab",
    "name": "Regressions",
    "description": "The following is a set of happy path system regressions in the form of user acceptance tests.",
    "schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
  },
  "item": [
    {
      "name": "Regressions setup",
      "item": [
        {
          "name": "1. Connect to the network",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "1fa7761c-dcd7-42ee-a984-4ffd3110f505",
                "exec": [
                  "async function main(){",
                  "const interval = setTimeout(() => {}, 60000);",
                  "console.log(\"Checkng that crypto example api is running. If not running it should be started within 60s of this call....\")",
                  "blsApiHealthcheck()",
                  "clearTimeout(interval)",
                  "",
                  "/*",
                  "Ensures the Example API required for inline functions such as encrypton and BLS is running",
                  "If this call fails or reaches a timeout, the example API server may be overloaded.",
                  "Please try again in a few minutes",
                  "*/",
                  "async function blsApiHealthcheck(){",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "    pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/health\") , function (err, response){",
                  "    resolve()",
                  "});",
                  " }).then(function(finalResult) {",
                  "     return finalResult;",
                  " })",
                  "}",
                  "",
                  "}",
                  "",
                  "main()",
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "5acadcaf-45d1-43e0-89f3-608ceeab761f",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5);",
                  "     if(pm.response.code != 200) {",
                  "        postman.setNextRequest(\"1. Remove temporary variables\")",
                  "    }",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"miners\", response.miners);",
                  "    pm.globals.set(\"sharders\", response.sharders);",
                  "});",
                  "",
                  "//disabling for now as this skews the rest results on multiple retries",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "d6b0767e-57ce-416b-a013-d621385f6005",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": "https://{{network}}/dns/network",
            "description": "Call 0Dns, get a list of miners/sharders needed for the rest of the test cases"
          },
          "response": []
        },
        {
          "name": "2. Check miner/sharder status",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "01b6a320-8f53-4165-a9ba-0cb3d3bb6824",
                "exec": [
                  "pm.test(\"Valid miner found\", function () {",
                  "    if(pm.variables.get(\"test_case_miner\") == undefined){",
                  "         postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(pm.variables.get(\"test_case_miner\")).not.eq(undefined);",
                  "});",
                  "",
                  "pm.test(\"Valid sharder found\", function () {",
                  "     if(pm.variables.get(\"test_case_sharder\") == undefined){",
                  "         postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(pm.variables.get(\"test_case_sharder\")).not.eq(undefined);",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "80b25c13-fedc-40dc-97a5-43e9f74224cf",
                "exec": [
                  "async function main(){",
                  "const interval = setTimeout(() => {}, 60000);",
                  "",
                  "miners = pm.variables.get(\"miners\")",
                  "for(i = 0; i < miners.length; i ++){",
                  "    miner = miners[i]",
                  "    if(isServiceUp(miner)){",
                  "        pm.globals.set(\"test_case_miner\", miner);",
                  "        break;",
                  "    }",
                  "}",
                  "",
                  "sharders = pm.variables.get(\"sharders\")",
                  "for(i = 0; i < sharders.length; i ++){",
                  "    sharder = sharders[i]",
                  "    if(isServiceUp(sharder)){",
                  "        pm.globals.set(\"test_case_sharder\", sharder);",
                  "        break;",
                  "    }",
                  "}",
                  "pm.globals.unset(\"miners\")",
                  "pm.globals.unset(\"sharders\")",
                  "",
                  "clearTimeout(interval)",
                  "",
                  "/*",
                  "Ensures the Example API required for inline functions such as encrypton and BLS is running",
                  "If this call fails or reaches a timeout, the example API server may be overloaded.",
                  "Please try again in a few minutes",
                  "*/",
                  "async function isServiceUp(endpoint){",
                  "    return await new Promise((resolve, reject) => {",
                  "    pm.sendRequest(endpoint + \"/health\" , function (err, response){",
                  "    resolve(response.code)",
                  "});",
                  " }).then(function(code) {",
                  "     console.log(\"response code for \" + endpoint + \" is \" + code)",
                  "   return code == 200;",
                  " })",
                  "}",
                  "",
                  "}",
                  "main();"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "8dcba8df-6b21-4744-833e-aa0dcc87309c",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "This does not test the network itself, rather sets up subsequent tests.  \nIterate through list of miners/sharders from 0dns, select a pair that are current returning a 200. These will be used for the remaining tests."
          },
          "response": []
        },
        {
          "name": "3. Generate Mnemonic",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "731590a1-aa9c-4c55-85c7-38944f371860",
                "exec": [
                  "var mnemonic = \"\";",
                  "for(i = 0; i < 24; i++){",
                  "    mnemonic += pm.variables.replaceIn('{{$randomLoremWord}} ');",
                  "}",
                  "mnemonic = mnemonic.trim();",
                  "",
                  "pm.environment.set(\"mnemonic\", mnemonic);",
                  "console.log(\"generated mnemonic is [\" + mnemonic + \"]\")"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "10499a4d-a6cd-4ed4-804c-5bbe95872c50",
                "exec": [
                  "pm.test(\"Mnemonic generated\", function () {",
                  "    if(pm.variables.get(\"mnemonic\") == undefined){",
                  "         postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(pm.variables.get(\"mnemonic\")).not.eq(undefined);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "8cf32493-1c1d-4424-b67a-e826de2833d0",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "This does not test the network itself, rather sets up subsequent tests.  \nGenerates a random 24-word mnemonic to be used for the rest of the tests"
          },
          "response": []
        }
      ],
      "id": "589856fc-9638-4a31-9214-089d0e113434"
    },
    {
      "name": "Create Wallet",
      "item": [
        {
          "name": "1. Create/Restore existing wallet",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "8485ee52-c678-4f03-8b0e-d6de27205de1",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "pm.test(\"Wallet id matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"wallet_id\"));",
                  "});",
                  "",
                  "pm.test(\"public key matches expected\", function () {",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.public_key).to.eql(pm.variables.get(\"public_key\"));",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "bc1b84db-3792-4d47-9f4a-a70eb5708acb",
                "exec": [
                  "async function main() {",
                  "    //postman boilerplate",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    //Calculates a BLS BN254 public key from the 24 word seed in your postman environment.",
                  "    //An external API is used for this calculation for the benefit of postman. In production",
                  "    //this would be a call to a locally running library or service.",
                  "    var public_key = await getPublicKey(pm.variables.get(\"mnemonic\"), \"0chain-client-split-key\")",
                  "    var publicKeyHexDump = toByteArray(public_key)",
                  "    pm.globals.set(\"public_key\", public_key);",
                  "    pm.globals.set(\"wallet_id\", await sha3256_Of_HexDump(publicKeyHexDump))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "",
                  "main()",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function getPublicKey(mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/publicKey?mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    Gets an 8-bit hex dump of the public key hex string",
                  "*/",
                  "function toByteArray(hexString) {",
                  "    var result = [];",
                  "    for (var i = 0; i < hexString.length; i += 2) {",
                  "        result.push(parseInt(hexString.substr(i, 2), 16));",
                  "    }",
                  "    return result;",
                  "}",
                  "",
                  "/*",
                  "    Ensure your SHA3-256 impl uses is standard, not keccak-256 (which is what CryptoJS uses)",
                  "    Calling a custom API here as the hashify API does not support hex dump byte arrays, but this is widely supported by hashing libraries",
                  "*/",
                  "async function sha3256_Of_HexDump(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sha3256Hash?data=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "a796bfb5-7a0b-4fc4-a594-d88360fb102e",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Accept",
                "value": "application/json",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"id\": \"{{wallet_id}}\",\n    \"version\": \"null\",\n    \"creation_date\": null,\n    \"public_key\": \"{{public_key}}\"\n}"
            },
            "url": "{{test_case_miner}}/v1/client/put",
            "description": "Create new wallet with mnemonic"
          },
          "response": []
        }
      ],
      "id": "82bc0be0-62d4-40d5-8318-d3f53a7c84cc"
    },
    {
      "name": "Execute Faucet",
      "item": [
        {
          "name": "1. Execute Faucet",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "09c303be-d6fc-4e1f-87ec-95b88fff0d2f",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    pm.globals.set(\"faucet_txn_hash\", response.entity.hash);",
                  "",
                  "    pm.test(\"Wallet id matches expected\", function () {",
                  "        pm.expect(response.entity.client_id).to.eql(pm.variables.get(\"wallet_id\"));",
                  "    });",
                  "",
                  "    pm.test(\"to_client_id matches expected\", function () {",
                  "        pm.expect(response.entity.to_client_id).to.eql(pm.variables.get(\"faucet_smart_contract_address\"));",
                  "    });",
                  "",
                  "    pm.test(\"signature matches expected\", function () {",
                  "     pm.expect(response.entity.signature).to.eql(pm.variables.get(\"signature\"));",
                  "    });",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "da0a349c-2450-40a4-a343-72505f30ab70",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "5a4eeba9-364a-48b5-a830-588eefb803cc",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json; charset=utf-8",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{faucet_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"pour\\\",\\\"input\\\":{},\\\"name\\\":null}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 10000000000,\n    \"txn_output_hash\": \"\",\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": "{{test_case_miner}}/v1/transaction/put",
            "description": "Execute faucet so the new wallet has tokens for the remaining tests"
          },
          "response": []
        },
        {
          "name": "2. Confirm Faucet execution",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "76a39b2e-6242-4631-9862-162461abea69",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5)",
                  "    if(pm.response.code != 200) {",
                  "        postman.setNextRequest(\"1. Remove temporary variables\")",
                  "    }",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "48627adb-2565-41be-934d-274502722a77",
                "exec": [
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "09b762a3-e2c5-45a1-92f9-80dfa6a80524",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{faucet_txn_hash}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{faucet_txn_hash}}",
                  "description": "The hash of the faucet transaction"
                }
              ]
            }
          },
          "response": []
        }
      ],
      "id": "80233311-e7e7-44ba-93d2-140a7cf5bce3"
    },
    {
      "name": "Create Allocation",
      "item": [
        {
          "name": "1. Create storage allocation with 60 min expiry",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "51f4b16c-ac5d-4526-a5e6-72ac2deb134e",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    var now = Math.round(Date.now() / 1000);",
                  "    pm.globals.set(\"current_timestamp\", now);",
                  "    pm.globals.set(\"expire_60_mins_from_now\", now + 36000);",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "3fb12ae7-016e-4b65-ad1e-aed6101f83f3",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"expire_60_mins_from_now\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"allocation_create_txn_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "ad819aa8-9c23-4d3c-b66b-02d530ba6441",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"new_allocation_request\\\",\\\"input\\\":{\\\"data_shards\\\":2,\\\"expiration_date\\\":{{expire_60_mins_from_now}},\\\"max_challenge_completion_time\\\":3600000000000,\\\"owner_id\\\":\\\"{{wallet_id}}\\\",\\\"owner_public_key\\\":\\\"{{public_key}}\\\",\\\"parity_shards\\\":1,\\\"read_price_range\\\":{\\\"min\\\":0,\\\"max\\\":9223372036854775807},\\\"size\\\":2147483648,\\\"write_price_range\\\":{\\\"min\\\":0,\\\"max\\\":9223372036854775807}}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 5000000000,\n    \"txn_output_hash\": \"\",\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": "{{test_case_miner}}/v1/transaction/put",
            "description": "Create a storage allocation, used in the remaining storage SC tests"
          },
          "response": []
        },
        {
          "name": "2. Confirm allocation creation",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "8af1e5f2-19c7-49c0-b75f-2cf269b8adee",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    var txn_output = JSON.parse(response.txn.transaction_output)",
                  "    pm.globals.set(\"allocation_id\", txn_output.id);",
                  "});   ",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "13d62186-a026-428e-ab3a-290ac2ad9160",
                "exec": [
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "20f3d2d3-b29c-48a7-bfe0-d4ad02ca0f0d",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{allocation_create_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{allocation_create_txn_id}}",
                  "description": "The hash of the allocation that we have requested be created "
                }
              ]
            }
          },
          "response": []
        }
      ],
      "id": "4802ee93-9c0e-4c34-b031-1614b229c1a3",
      "description": "A storage allocation is an assignment of blobbers, with each blobber providing a set amount of storage space. Files are uploaded to an allocation and are deleted when the allocation expires.\nThe allocation is configurable in terms of expiry time, storage size, blobber performance, blobber geo-location, token cost and [erasure-coding](https://en.wikipedia.org/wiki/Binary_Reed%E2%80%93Solomon_encoding) ratio.  \n\nZCN are locked for the duration of an allocation and the majority released after it expires.  \nThe amount of tokens required for an allocation depends on a number of factors including (but not limited to) how much storage space is required and the number of blobbers required (EC ratio).\n\n# Requirements\n- Create a wallet\n- Add test ZCN to wallet",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "5b3992cd-55b8-4c17-b1ba-6e0756a78d3f",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "835708d8-129a-4b3a-ba52-2655334f8a39",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Retrieve Allocation",
      "item": [
        {
          "name": "1. Retrieve all storage allocations",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "96dd89c4-9194-4df7-9e62-e46fda01e8ec",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {    ",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "pm.test(\"Number of allocations matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.length).to.eql(1)",
                  "});   ",
                  "",
                  "pm.test(\"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response[0].id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});  ",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "953c7ba0-598d-4fc1-81a9-4ee2c343e9e5",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocations?client={{wallet_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocations"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                }
              ]
            },
            "description": "Retrieve all storage allocations belonging to the wallet. At this point there should be a single allocation present"
          },
          "response": []
        },
        {
          "name": "2. Retrieve single storage allocation",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "30057efe-2713-4dbe-b26a-f9eb22997902",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    if(pm.response.code != 200) {",
                  "        postman.setNextRequest(null)",
                  "    }",
                  "    ",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    // sets the data we need for subsequent requests.",
                  "    // currently this is hardcoded for 4 blobbers for demonstration purposes.",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "});   ",
                  "",
                  "pm.test(\"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});   ",
                  "",
                  "pm.test(\"Allocation txn id matches create txn id\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.tx).to.eql(pm.variables.get(\"allocation_create_txn_id\"))",
                  "    pm.globals.unset(\"allocation_create_txn_id\")",
                  "});",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "4b19f007-cd9b-4865-84e6-39eca6c2b837",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Retrieve the newly created storage allocation. Data from the result of this test will be used  during the upload test cases"
          },
          "response": []
        }
      ],
      "id": "f15e2df0-cfab-4dcb-b0c8-d6024c05bd2e"
    },
    {
      "name": "Update Allocation",
      "item": [
        {
          "name": "1. Update storage allocation",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "f12212e2-1d9a-42f2-b6d6-a574ecb445ed",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    var now = Math.round(Date.now() / 1000);",
                  "    pm.globals.set(\"current_timestamp\", now);",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "c4ec8eb9-bb9e-4ed5-abd0-fcfef341d945",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"update_allocation_txn_id\", response.entity.hash);",
                  "    ",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "});    "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "0c999a12-c4af-4ab5-88c9-7f0d4fedc673",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"public_key\": \"{{public_key}}\",\n    \"signature\": \"{{signature}}\",\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{\\\"name\\\":\\\"update_allocation_request\\\",\\\"input\\\":{\\\"expiration_date\\\":0,\\\"id\\\":\\\"{{allocation_id}}\\\",\\\"owner_id\\\":\\\"{{wallet_id}}\\\",\\\"size\\\":1, \\\"expiration_date\\\":0}}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"txn_output_hash\": \"\",\n    \"version\": \"1.0\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": "{{test_case_miner}}/v1/transaction/put",
            "description": "Update storage allocation, adding size.  \nNB there is currently a known BUG with updating expiry to be in the future. This test case should be update when the bug is fixed."
          },
          "response": []
        },
        {
          "name": "2. Confirm allocation update",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "2a4fe545-3e62-43e0-9d05-5573e58803bc",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5);",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "});   ",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "f0c20209-f4c6-4766-8fed-a39ba022db8c",
                "exec": [
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "78aaca7e-3d17-4e9d-aa8f-da2717069894",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{update_allocation_txn_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{update_allocation_txn_id}}"
                }
              ]
            }
          },
          "response": []
        },
        {
          "name": "3. Retrieve updated allocation",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "e4c94c8b-caa3-4a20-8163-d5ba9fbab466",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    // sets the data we need for subsequent requests.",
                  "    // currently this is hardcoded for 4 blobbers for demonstration purposes.",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "});   ",
                  "",
                  "pm.test(\"Allocation id matches expected\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.id).to.eql(pm.variables.get(\"allocation_id\"))",
                  "});   ",
                  "",
                  "pm.test(\"Allocation txn id matches update txn id\", function () {    ",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.expect(response.tx).to.eql(pm.variables.get(\"update_allocation_txn_id\"))",
                  "    pm.globals.unset(\"update_allocation_txn_id\");",
                  "});   ",
                  "",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "4c0b2d3d-387e-406d-a82d-9e990abddb26",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Ensure the updated allocation is still retrievable using the original id.  \nEnsure the txn field has been updated with the update txn id"
          },
          "response": []
        }
      ],
      "id": "87f26692-410c-46fe-8020-f7e124cce8d5",
      "description": "A storage allocation is an assignment of blobbers, with each blobber providing a set amount of storage space. Files are uploaded to an allocation and are deleted when the allocation expires.\nThe allocation is configurable in terms of expiry time, storage size, blobber performance, blobber geo-location, token cost and [erasure-coding](https://en.wikipedia.org/wiki/Binary_Reed%E2%80%93Solomon_encoding) ratio.  \n\nZCN are locked for the duration of an allocation and the majority released after it expires.  \nThe amount of tokens required for an allocation depends on a number of factors including (but not limited to) how much storage space is required and the number of blobbers required (EC ratio).\n\n# Requirements\n- Create a wallet\n- Add test ZCN to wallet",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "2a3bf517-8737-49ae-b941-f767882e110f",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "83829b28-bf92-4012-aadd-f0fba12ce2fa",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        }
      ]
    },
    {
      "name": "Upload a file",
      "item": [
        {
          "name": "1. Process and erasure code file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "835529fe-a6ba-4072-87da-8ac787972113",
                "exec": [
                  "//variable boilerplate required for subsequent requests.",
                  "var local_filePath = pm.request.body.formdata.find(e => e.key == \"file\").src",
                  "pm.globals.set(\"local_filepath\", local_filePath);",
                  "pm.globals.set(\"filename\", local_filePath.split(\"/\").pop());",
                  "pm.globals.set(\"remote_filepath\", \"/{{filename}}\")",
                  "pm.globals.set(\"erasure_coding_example_api\", \"https://example-0chain-crypto.herokuapp.com/erasureCode\")"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "7bdf8ecc-5cf1-4efb-b8ed-38b5f14009e5",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "",
                  "    // get the file hash and size from the API as well as parity and data shards.",
                  "    // currently hardcoded for 4 shards.",
                  "    pm.globals.set(\"fileHash\", response.sha1Hash);",
                  "    pm.globals.set(\"fileSize\", response.fileSize);",
                  "",
                  "    for(i =0; i < response.ecShards.length; i ++){",
                  "       pm.globals.set(\"ec_shard_\" + i, response.ecShards[i]);",
                  "    }",
                  "",
                  "    pm.globals.set(\"current_blobber_number\", 0)",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "abcc175a-2a1a-4d24-8e2c-04e73e09b8a3",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "file",
                  "description": "This is not a 0chain api call but is analogous to using your programming language's read file function. Choose the file you wish to upload.",
                  "type": "file",
                  "src": "test_file"
                }
              ]
            },
            "url": {
              "raw": "{{erasure_coding_example_api}}?numDataShards={{num_data_shards}}&numParityShards={{num_parity_shards}}",
              "host": [
                "{{erasure_coding_example_api}}"
              ],
              "query": [
                {
                  "key": "numDataShards",
                  "value": "{{num_data_shards}}"
                },
                {
                  "key": "numParityShards",
                  "value": "{{num_parity_shards}}"
                }
              ]
            },
            "description": "TODO: This call can be removed and the upload values hardcoded"
          },
          "response": []
        },
        {
          "name": "2. Upload EC shard 1 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "6c6024ba-5534-49e3-be2f-3c2d25a1dd4b",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_0\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "dfd313c7-1772-4ba0-ae81-0297c075b21e",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "add2d667-2584-46f1-8af9-9748375b393f",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": "{{blobber0_url}}/v1/file/upload/{{allocation_id}}",
            "description": "Once the file hash, size and EC shards have been calculated, the file can be uploaded by sending a multipart form to the blobber with the EC shard for that blobber.  \n\nRemember that only the single EC shard for this blobber is uploaded, not the entire file.  \n\nThe below example shows a raw multipart form request which may be necessary if your library (such as postman!!) only supports full file upload \n\nHowever, in languages such as Java, partial binary is supported via streams in many libraries HTTP clients without requiring a raw form request to be created.  \n  \n\n**Requirements to make this request:**\n\n**uploadFile**:  \nThe Reed-Solomon data shard from the previous step  \n**connection_id**:  \nA unique 9 digit integer id that will tie this upload to subsequent commit requests.  \n**uploadMeta**\nA JSON object containing metadata for the current request.Thee object must contain the following fields:  \n\n| Field        | Description           |\n| ------------- |:-------------:|\n| connection_id | Same as above   |\n| filename | The name of the destination file |\n| filepath | The full destination file path |\n| actual_hash | The SHA1 hash of the **original** file (not the current shard)   |\n| actual_size | the size of the **original** file (not the current shard) in bytes |"
          },
          "response": []
        },
        {
          "name": "3. Get file reference path for EC shard 1",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "9e0ea684-a8df-4768-801c-fd6e60ef4a10",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "1135d578-5678-4484-8f39-95e5c55541ef",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "dbb56a03-68c1-4611-beed-7c616e43ca97",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber0_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber0_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            },
            "description": "The file reference path details all files in the directory we are uploading to. It is important to have this information in the next step, as we will be inserting a new entry to this reference path and re-calculating it's hash"
          },
          "response": []
        },
        {
          "name": "4. Commit Upoad of EC shard 1",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "2a86d7bf-c7e5-49ff-8d21-8d509c68948f",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.remove(0);",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            addFileToTree(dir, uploadResult, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            attributes: uploadRequest.attributes,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "        console.log(\"after\")",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash, JSON.stringify(metaData.attributes)].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == undefined) {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "7234e2cf-8f43-4972-b1c7-71bb44477696",
                "exec": [
                  "",
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "80c2a397-5b32-4ea7-b662-345e8e21f095",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber0_url}}/v1/connection/commit/{{allocation_id}}",
            "description": "In a similar fashion to some databases, a file is not persisted permanently to the blobber until it is comitted.  \n0Chain keeps it's network fast by storing data off-chain while maintaining the benefits of on-chain storage by comitting the allocation metadata to the blockchain.\n  \nA commit requires a write marker. Think of this as the latest entry in an audit trail containing the hash of the entire allocation at the time of upload and a link to the previous write market in the form of the hash of the previous allocation state.  \n\n**This is a major benefit of 0chain - a GDPR compliant, transparent and immutable audit log is a mandatory feature of the platform.**  \n\n**Requirements to make this request:**  \nCreate a new write marker using the reference path:\n- Set previous allocation root to current allocation root \n- Traverse through file tree until file path is reached\n- Add file metadata entry to that directory\n- recalculate directory hash\n- recalculate all parent directory hashes\n- recalculate root directory hash\n\n- set allocation root to root directory hash with timestamp\n- BLS signature sign the request\n\n\nShard is now successfully uploaded to a blobber.\n\n**Now Repeat steps 3, 4 and 5 for each remaining blobber, postman will auto-increment the current blobber and EC shard for you**"
          },
          "response": []
        },
        {
          "name": "5. Upload EC shard 2 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "6b845b06-09d1-4b68-965d-f8ce6cc1d54a",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "  ",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber1_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_1\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "99f967e5-5540-4693-9681-e3703a317fb8",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "37045f21-eeba-4bbf-b102-d51203496cea",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": "{{blobber1_url}}/v1/file/upload/{{allocation_id}}",
            "description": "Once the file hash, size and EC shards have been calculated, the file can be uploaded by sending a multipart form to the blobber with the EC shard for that blobber.  \n\nRemember that only the single EC shard for this blobber is uploaded, not the entire file.  \n\nThe below example shows a raw multipart form request which may be necessary if your library (such as postman!!) only supports full file upload \n\nHowever, in languages such as Java, partial binary is supported via streams in many libraries HTTP clients without requiring a raw form request to be created.  \n  \n\n**Requirements to make this request:**\n\n**uploadFile**:  \nThe Reed-Solomon data shard from the previous step  \n**connection_id**:  \nA unique 9 digit integer id that will tie this upload to subsequent commit requests.  \n**uploadMeta**\nA JSON object containing metadata for the current request.Thee object must contain the following fields:  \n\n| Field        | Description           |\n| ------------- |:-------------:|\n| connection_id | Same as above   |\n| filename | The name of the destination file |\n| filepath | The full destination file path |\n| actual_hash | The SHA1 hash of the **original** file (not the current shard)   |\n| actual_size | the size of the **original** file (not the current shard) in bytes |"
          },
          "response": []
        },
        {
          "name": "6. Get file reference path for EC shard 2",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "709dbf88-b3db-4a9c-9359-3c89c6e3adf4",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "110f9d33-741b-4256-812c-9e970c7d8a39",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "5b71c4be-de2b-49b6-aea7-92d727dd5783",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber1_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber1_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            },
            "description": "The file reference path details all files in the directory we are uploading to. It is important to have this information in the next step, as we will be inserting a new entry to this reference path and re-calculating it's hash"
          },
          "response": []
        },
        {
          "name": "7. Commit Upoad of EC shard 2",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "08780285-b93c-40d6-96d1-0769e1c1a17d",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.remove(0);",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            addFileToTree(dir, uploadResult, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            attributes: uploadRequest.attributes,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "        console.log(\"after\")",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash, JSON.stringify(metaData.attributes)].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == undefined) {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "dbe1cc3f-690f-4deb-acf9-205c9f9a97f1",
                "exec": [
                  "",
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "    var num_parity_shards = pm.variables.get(\"num_parity_shards\")",
                  "",
                  "    if(current_blobber_number >= (num_data_shards + num_parity_shards)){",
                  "        console.log(\"All Blobbers have successfully been committed to, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "1de77e01-7803-44f7-be6a-be0988953b73",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber1_url}}/v1/connection/commit/{{allocation_id}}",
            "description": "In a similar fashion to some databases, a file is not persisted permanently to the blobber until it is comitted.  \n0Chain keeps it's network fast by storing data off-chain while maintaining the benefits of on-chain storage by comitting the allocation metadata to the blockchain.\n  \nA commit requires a write marker. Think of this as the latest entry in an audit trail containing the hash of the entire allocation at the time of upload and a link to the previous write market in the form of the hash of the previous allocation state.  \n\n**This is a major benefit of 0chain - a GDPR compliant, transparent and immutable audit log is a mandatory feature of the platform.**  \n\n**Requirements to make this request:**  \nCreate a new write marker using the reference path:\n- Set previous allocation root to current allocation root \n- Traverse through file tree until file path is reached\n- Add file metadata entry to that directory\n- recalculate directory hash\n- recalculate all parent directory hashes\n- recalculate root directory hash\n\n- set allocation root to root directory hash with timestamp\n- BLS signature sign the request\n\n\nShard is now successfully uploaded to a blobber.\n\n**Now Repeat steps 3, 4 and 5 for each remaining blobber, postman will auto-increment the current blobber and EC shard for you**"
          },
          "response": []
        },
        {
          "name": "8. Upload EC shard 3 to blobber",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "038eeff5-65d6-49a9-99d0-5247adca6ed4",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "",
                  "    pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber2_id\"));",
                  "    pm.globals.set(\"connection_id_for_current_blobber\", _.random(100000000, 999999999));",
                  "    pm.globals.set(\"current_ec_shard\", pm.variables.get(\"ec_shard_2\"))",
                  "",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "3bc2c28a-e042-46be-8f58-5d1bd116d952",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"uploadResponse\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "beb2f3b4-32ec-49f7-8525-85271a2c1c41",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {}
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "multipart/form-data;boundary=Xform_data_boundary_exampleX",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{{upload-request}}"
            },
            "url": "{{blobber2_url}}/v1/file/upload/{{allocation_id}}",
            "description": "Once the file hash, size and EC shards have been calculated, the file can be uploaded by sending a multipart form to the blobber with the EC shard for that blobber.  \n\nRemember that only the single EC shard for this blobber is uploaded, not the entire file.  \n\nThe below example shows a raw multipart form request which may be necessary if your library (such as postman!!) only supports full file upload \n\nHowever, in languages such as Java, partial binary is supported via streams in many libraries HTTP clients without requiring a raw form request to be created.  \n  \n\n**Requirements to make this request:**\n\n**uploadFile**:  \nThe Reed-Solomon data shard from the previous step  \n**connection_id**:  \nA unique 9 digit integer id that will tie this upload to subsequent commit requests.  \n**uploadMeta**\nA JSON object containing metadata for the current request.Thee object must contain the following fields:  \n\n| Field        | Description           |\n| ------------- |:-------------:|\n| connection_id | Same as above   |\n| filename | The name of the destination file |\n| filepath | The full destination file path |\n| actual_hash | The SHA1 hash of the **original** file (not the current shard)   |\n| actual_size | the size of the **original** file (not the current shard) in bytes |"
          },
          "response": []
        },
        {
          "name": "9. Get file reference path for EC shard 3",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "72bc49e4-b50c-4742-934a-3c89e1179f04",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"referencePathResponseForCurrentBlobber\", response);",
                  "});   "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "cd399283-6ebd-444d-9fa3-926386cd8a36",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "442ba082-6078-4fbc-962c-33097bcc5ef6",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{blobber2_url}}/v1/file/referencepath/{{allocation_id}}?paths=[\"{{remote_filepath}}\"]",
              "host": [
                "{{blobber2_url}}"
              ],
              "path": [
                "v1",
                "file",
                "referencepath",
                "{{allocation_id}}"
              ],
              "query": [
                {
                  "key": "paths",
                  "value": "[\"{{remote_filepath}}\"]"
                }
              ]
            },
            "description": "The file reference path details all files in the directory we are uploading to. It is important to have this information in the next step, as we will be inserting a new entry to this reference path and re-calculating it's hash"
          },
          "response": []
        },
        {
          "name": "10. Commit Upoad of EC shard 3",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "5c76a81f-410f-47ff-bf63-c6b1547311f4",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var timestamp = Math.round(Date.now() / 1000);",
                  "    var allocationId = blankIfUndefined(pm.variables.get(\"allocation_id\"))",
                  "    var blobberId = blankIfUndefined(pm.variables.get(\"blobber_id_matching_current_blobber\"))",
                  "    var walletId = blankIfUndefined(pm.variables.get(\"wallet_id\"))",
                  "    var mnemonics = pm.variables.get(\"mnemonic\")",
                  "",
                  "",
                  "    //Add the current file to the file reference path and re-compute directory hashes.\t",
                  "    //This requires data from the original upload request, the upload response and the file reference path.",
                  "    var blobberReferencePath = pm.variables.get(\"referencePathResponseForCurrentBlobber\")",
                  "    var uploadResponse = pm.variables.get(\"uploadResponse\")",
                  "    var uploadRequest = JSON.parse(Property.replaceSubstitutions(pm.variables.get(\"upload-metadata\"), pm.variables.toObject()))",
                  "    await addFileToReferencePath(blobberReferencePath, uploadResponse, uploadRequest)",
                  "    ",
                  "",
                  "    //calculate the new allocation root hash",
                  "    var hashData = (await hashCurrentFileRoot(blobberReferencePath) + \":\" + timestamp)",
                  "    var newly_calculated_allocation_root = await sha3256(hashData)",
                  "",
                  "    //sign the request",
                  "    var prevAllocationRoot = (blobberReferencePath.latest_write_marker == undefined ? \"\" : blobberReferencePath.latest_write_marker.allocation_root);",
                  "    var fileSize = blankIfUndefined(uploadResponse.size)",
                  "    var signatureHashData = await sha3256([newly_calculated_allocation_root,",
                  "        prevAllocationRoot,",
                  "        allocationId,",
                  "        blobberId,",
                  "        walletId,",
                  "        fileSize,",
                  "        timestamp",
                  "    ].join(\":\"))",
                  "    var signature = await sign(signatureHashData, mnemonics, \"0chain-client-split-key\")",
                  "",
                  "    pm.globals.set(\"newly_calculated_allocation_root\", newly_calculated_allocation_root);",
                  "    pm.globals.set(\"current_timestamp\", timestamp);",
                  "    pm.globals.set(\"prevAllocationRootForCurrentBlobber\", prevAllocationRoot);",
                  "    pm.globals.set(\"signature\", signature)",
                  "    pm.globals.set(\"file_size\", uploadResponse.size)",
                  "",
                  "    clearTimeout(interval)",
                  "",
                  "",
                  "    async function addFileToReferencePath(blobberReferencePath, uploadResult, uploadRequest) {",
                  "",
                  "        var filePath = uploadRequest.filepath.split('/');",
                  "        var index = filePath.indexOf(\"\");",
                  "",
                  "        if (index !== -1) {",
                  "            filePath.splice(index, 1);",
                  "        }",
                  "",
                  "        await addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath)",
                  "    }",
                  "",
                  "    async function addFileToTree(blobberReferencePath, uploadResult, uploadRequest, filePath) {",
                  "        if (isFile(filePath)) {",
                  "            await addFile(blobberReferencePath, uploadRequest, uploadResult);",
                  "            blobberReferencePath.meta_data.hash = await hashCurrentFileRoot(blobberReferencePath);",
                  "        } else {",
                  "            dirName = filePath.remove(0);",
                  "            dir = getDir(dirName, blobberReferencePath);",
                  "            addFileToTree(dir, uploadResult, filePath);",
                  "            dir.meta_data.hash = await hashCurrentFileRoot(dir);",
                  "        }",
                  "    }",
                  "",
                  "    async function addFile(blobberReferencePath, uploadRequest, uploadResult) {",
                  "        var metaData = {",
                  "            type: \"f\",",
                  "            name: uploadRequest.filename,",
                  "            path: uploadRequest.filepath,",
                  "            size: uploadResult.size,",
                  "            content_hash: uploadResult.content_hash,",
                  "            merkle_root: uploadResult.merkle_root,",
                  "            actual_file_hash: uploadRequest.actual_hash,",
                  "            actual_file_size: uploadRequest.actual_size,",
                  "            attributes: uploadRequest.attributes,",
                  "            hash: undefined,",
                  "            path_hash: undefined",
                  "        }",
                  "        console.log(\"after\")",
                  "",
                  "",
                  "        metaData.hash = await sha3256([allocationId, metaData.type, metaData.name, metaData.path, metaData.size, metaData.content_hash, metaData.merkle_root, metaData.actual_file_size, metaData.actual_file_hash, JSON.stringify(metaData.attributes)].join(\":\"))",
                  "",
                  "        metaData.path_hash = await sha3256([allocationId, metaData.path].join(\":\"))",
                  "",
                  "        var newFilePath = {",
                  "            meta_data: metaData",
                  "        }",
                  "",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        blobberReferencePath.list.filter(entry => uploadResult.filepath != entry.meta_data.path);",
                  "        blobberReferencePath.list.add(newFilePath);",
                  "    }",
                  "",
                  "    function isFile(path) {",
                  "        return path.length == 1;",
                  "    }",
                  "",
                  "    function getDir(dirName, blobberReferencePath) {",
                  "        if (blobberReferencePath.list == undefined) {",
                  "            blobberReferencePath.list = [];",
                  "        }",
                  "        var existingDir = blobberReferencePath.list.filter(e => dirName == e.meta_data.name && \"d\" == e.meta_data.type);",
                  "",
                  "        if (existingDir == undefined) {",
                  "            var newDir = {",
                  "                list: [],",
                  "                meta_data: {",
                  "                    type: \"d\",",
                  "                    path: blobberReferencePath.meta_data.path.endsWith(\"/\") ? (blobberReferencePath.meta_data.path + dirName) : (blobberReferencePath.meta_data.path + \"/\" + dirName)",
                  "                }",
                  "            }",
                  "            blobberReferencePath.list.add(newDir)",
                  "            return newDir;",
                  "        } else {",
                  "            return existingDir;",
                  "        }",
                  "    }",
                  "",
                  "    async function hashCurrentFileRoot(blobberReferencePath) {",
                  "        if (\"f\" == (blobberReferencePath.meta_data.type) || blobberReferencePath.list == undefined || blobberReferencePath.list.length == 0) {",
                  "            return blobberReferencePath.meta_data.hash;",
                  "        } else {",
                  "            await blobberReferencePath.list.sort(async function(path1, path2) {",
                  "                var path1Hash = await sha3256(allocationId + \":\" + path1.meta_data.path);",
                  "                var path2Hash = await sha3256(allocationId + \":\" + path2.meta_data.path);",
                  "",
                  "                return path1Hash.localeCompare(path2Hash);",
                  "            });",
                  "",
                  "            return await sha3256(blobberReferencePath.list.map(ref => ref.meta_data.hash).join(\":\"))",
                  "        }",
                  "    }",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "function blankIfUndefined(str) {",
                  "    return str == undefined ? \"\" : str;",
                  "}",
                  "",
                  "main()"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "e85cf963-b556-4d93-9b71-4bd7cccda224",
                "exec": [
                  "",
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "    var num_parity_shards = pm.variables.get(\"num_parity_shards\")",
                  "",
                  "    if(current_blobber_number >= (num_data_shards + num_parity_shards)){",
                  "        console.log(\"All Blobbers have successfully been committed to, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "7137fcbc-13a9-419a-a613-531bced2d16a",
          "protocolProfileBehavior": {
            "disableBodyPruning": true,
            "disabledSystemHeaders": {
              "connection": true,
              "accept-encoding": true,
              "accept": true,
              "user-agent": true
            }
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "Connection",
                "value": "Keep-Alive",
                "type": "text"
              },
              {
                "key": "Cache-Control",
                "value": "no-cache",
                "type": "text"
              },
              {
                "key": "Transfer-Encoding",
                "value": "chunked",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{connection_id_for_current_blobber}}",
                  "description": "The connection you wish to commit",
                  "type": "text"
                },
                {
                  "key": "write_marker",
                  "value": "{\n\"allocation_root\" : \"{{newly_calculated_allocation_root}}\",\n\"prev_allocation_root\" : \"{{prevAllocationRootForCurrentBlobber}}\",\n\"allocation_id\" : \"{{allocation_id}}\",\n\"size\" : {{file_size}},\n\"blobber_id\" : \"{{blobber_id_matching_current_blobber}}\",\n\"timestamp\" : {{current_timestamp}},\n\"client_id\" : \"{{wallet_id}}\",\n\"signature\" : \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber2_url}}/v1/connection/commit/{{allocation_id}}",
            "description": "In a similar fashion to some databases, a file is not persisted permanently to the blobber until it is comitted.  \n0Chain keeps it's network fast by storing data off-chain while maintaining the benefits of on-chain storage by comitting the allocation metadata to the blockchain.\n  \nA commit requires a write marker. Think of this as the latest entry in an audit trail containing the hash of the entire allocation at the time of upload and a link to the previous write market in the form of the hash of the previous allocation state.  \n\n**This is a major benefit of 0chain - a GDPR compliant, transparent and immutable audit log is a mandatory feature of the platform.**  \n\n**Requirements to make this request:**  \nCreate a new write marker using the reference path:\n- Set previous allocation root to current allocation root \n- Traverse through file tree until file path is reached\n- Add file metadata entry to that directory\n- recalculate directory hash\n- recalculate all parent directory hashes\n- recalculate root directory hash\n\n- set allocation root to root directory hash with timestamp\n- BLS signature sign the request\n\n\nShard is now successfully uploaded to a blobber.\n\n**Now Repeat steps 3, 4 and 5 for each remaining blobber, postman will auto-increment the current blobber and EC shard for you**"
          },
          "response": []
        }
      ],
      "id": "6ec5bcac-b9ff-4d14-bac9-cbf1388c0a8b",
      "description": "The following requests detail the sharding, uploading and committing files to the network.\n\nSteps 1 and 2 need only be performed once, Steps 3, 4 and 5 need to be performed as a group n times where n is the number of blobbers in the storage allocation.\n\neg.for an allocation with 4 blobbers:  \nRun Steps 1 & 2 then  \nfor blobber 1 -> [Run Steps 3, 4, 5] then  \nfor blobber 2 -> [Run Steps 3, 4, 5] then  \nfor blobber 3 -> [Run Steps 3, 4, 5] then  \nfor blobber 4 -> [Run Steps 3, 4, 5]\n\nPostman will switch to the next blobber and shard after the previous blobber has been comitted to successfully.\n\n\n# Requirements\n- Create a wallet\n- Create an allocation",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "70f49140-04bd-4131-8729-387672d683b2",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "e3982994-de9f-47d9-836c-84330386db22",
            "type": "text/javascript",
            "exec": [
              "  if(pm.response.code != 200) {",
              "        postman.setNextRequest(\"1. Create read pool\")",
              "    }"
            ]
          }
        }
      ]
    },
    {
      "name": "Lock read tokens",
      "item": [
        {
          "name": "1. Create read pool",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "2fb3d62c-c64b-49c4-9180-2742af2613b9",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"read_pool_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "a520af5d-79f5-4dcf-b64d-d7ad01129197",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "0673dc48-4521-43ce-86b1-127e15ae6c91",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\":\"{\\\"name\\\":\\\"new_read_pool\\\",\\\"input\\\":null}\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 0,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": "{{test_case_miner}}/v1/transaction/put",
            "description": "The following request asks the miners to create a read pool for a storage allocation.  \nThe hash of this transaction will become the read pool id.\n\n**Requirements to make this request:**  \n**Hash**\nA SHA3-256 hash of a colon delimited string of [creation_date, client_id, to_client_id, transaction_value and the SHA3-256 hash of transaction_data]  \n**Signature**\nA BLS signature of the Hash  \n**Client Id**\nYour wallet id  \n**Public Key**\nThe hex string of the BLS public key  \n**Creation date**\nThe current unix epoch timestamp  \n**To client Id**\nThe Id of the smart contract you wish to execute the transaction data on  \n**Transaction data**\nRead pool specific setup such as duration and allocation id goes here"
          },
          "response": []
        },
        {
          "name": "2. Confirm pool created",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "4c8681f3-cf8c-4a70-afea-b1e6d816bbaa",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5);",
                  "    if(pm.response.code != 200) {",
                  "        postman.setNextRequest(null)",
                  "    }",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"read_pool_id\", response.hash);",
                  "});    ",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "8867706a-c930-49fd-96d3-f8431709f97a",
                "exec": [
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "59fe3052-4395-4e84-abb2-2feebcfb7459",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{read_pool_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{read_pool_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        },
        {
          "name": "3. Lock read tokens",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "6d0cb276-66e1-438f-bda4-5f8c87563599",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    pm.globals.unset(\"current_timestamp\");",
                  "    pm.globals.unset(\"hash_of_request_data\");",
                  "    pm.globals.unset(\"signature\");",
                  "",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"read_pool_id\", response.entity.hash);",
                  "});    "
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "71f0a2a5-5757-4bcc-bb12-0d5b2147dce9",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    // timestamp is in the unix epoch (seconds) format",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "",
                  "    // postman boilerplate to retrieve the request body, we need data from here for the hash",
                  "    var requestBody = JSON.parse(Property.replaceSubstitutions(pm.request.body.raw, pm.variables.toObject()))",
                  "    var creationDate = requestBody.creation_date",
                  "    var clientId = requestBody.client_id;",
                  "    var toClientId = requestBody.to_client_id;",
                  "    var transactionValue = requestBody.transaction_value;",
                  "",
                  "    var transactionDataHash = await sha3256(requestBody.transaction_data)",
                  "",
                  "    //if hash data is not available, we insert a blank string rather than hashing one less item",
                  "    var overallHashData = (",
                  "        (creationDate == undefined ? \"\" : creationDate) + \":\" +",
                  "        (clientId == undefined ? \"\" : clientId) + \":\" +",
                  "        (toClientId == undefined ? \"\" : toClientId) + \":\" +",
                  "        (transactionValue == undefined ? \"\" : transactionValue) + \":\" +",
                  "        transactionDataHash",
                  "    )",
                  "    var overallHash = await sha3256(overallHashData)",
                  "",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "1e3e4f89-d476-4752-9778-ceeade9badd0",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"hash\": \"{{hash_of_request_data}}\",\n    \"signature\": \"{{signature}}\",\n    \"version\": \"1.0\",\n    \"client_id\": \"{{wallet_id}}\",\n    \"creation_date\": {{current_timestamp}},\n    \"to_client_id\": \"{{storage_smart_contract_address}}\",\n    \"transaction_data\": \"{ \\\"name\\\": \\\"read_pool_lock\\\", \\\"input\\\": { \\\"duration\\\": 2592000000000000, \\\"allocation_id\\\": \\\"{{allocation_id}}\\\" } }\",\n    \"transaction_fee\": 0,\n    \"transaction_type\": 1000,\n    \"transaction_value\": 5000000000,\n    \"public_key\": \"{{public_key}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": "{{test_case_miner}}/v1/transaction/put",
            "description": "The following request asks the miners to create a read pool for a storage allocation.  \nThe hash of this transaction will become the read pool id.\n\n**Requirements to make this request:**  \n**Hash**\nA SHA3-256 hash of a colon delimited string of [creation_date, client_id, to_client_id, transaction_value and the SHA3-256 hash of transaction_data]  \n**Signature**\nA BLS signature of the Hash  \n**Client Id**\nYour wallet id  \n**Public Key**\nThe hex string of the BLS public key  \n**Creation date**\nThe current unix epoch timestamp  \n**To client Id**\nThe Id of the smart contract you wish to execute the transaction data on  \n**Transaction data**\nRead pool specific setup such as duration and allocation id goes here"
          },
          "response": []
        },
        {
          "name": "4. Confirm token lock",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "ac0adc53-9278-46bd-a041-b00a4bd49254",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5);",
                  "    if(pm.response.code != 200) {",
                  "        postman.setNextRequest(\"1. Remove temporary variables\")",
                  "    }",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "3e6135f5-9585-40d0-81d2-6b5b36dc2174",
                "exec": [
                  "utils.delayTestUntilHttpCodeReceived(pm, 200)"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "153c31a1-e1fd-4f0c-9a37-ff007a701e70",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/transaction/get/confirmation?hash={{read_pool_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "transaction",
                "get",
                "confirmation"
              ],
              "query": [
                {
                  "key": "hash",
                  "value": "{{read_pool_id}}",
                  "description": "The read pool that we have requested be created "
                }
              ]
            },
            "description": "Similar to the create allocation and faucet requests, the lock read tokens request must be confirmed by a consensus of sharders before the read pool can be considered created."
          },
          "response": []
        }
      ],
      "id": "f3cd1603-1165-4dc7-93a8-8dc4357ee091",
      "description": "On the 0chain network, there are two billable events when it comes to data: reads and writes.  \nLocking tokens in a storage allocation automatically create a write pool which covers data writes eg. uploads.  \n\nData reads are covered by locking tokens in a read pool. A read pool is tied to an allocation and allows the data stored in that allocation to be read (downloaded or streamed).     \n\n# Requirements\n- Create a wallet\n- create an allocation",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "c689c5e4-5a54-4528-83c3-5e5bce04c180",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "be88174e-f825-4e84-a20c-c87bec0c3c5b",
            "type": "text/javascript",
            "exec": [
              "  if(pm.response.code != 200) {",
              "        postman.setNextRequest(\"1. Retrieve storage allocation for download\")",
              "    }"
            ]
          }
        }
      ]
    },
    {
      "name": "Download a file",
      "item": [
        {
          "name": "1. Retrieve storage allocation for download",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "f2d41029-d473-4a96-a2cf-6d10f7cc5deb",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"num_data_shards\", response.data_shards);",
                  "    pm.globals.set(\"num_parity_shards\", response.parity_shards);",
                  "",
                  "    for(i =0; i < response.blobbers.length; i ++){",
                  "        pm.globals.set(\"blobber\" + i + \"_url\", response.blobbers[i].url);",
                  "        pm.globals.set(\"blobber\" + i + \"_id\", response.blobbers[i].id);",
                  "    }",
                  "",
                  "    pm.globals.set(\"current_blobber_number\", 0)",
                  "    pm.globals.set(\"downloaded_shards\", \"\")",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "d203cc02-0265-4e2f-9f62-547d97256e5d",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/{{storage_smart_contract_address}}/allocation?allocation={{allocation_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                "{{storage_smart_contract_address}}",
                "allocation"
              ],
              "query": [
                {
                  "key": "allocation",
                  "value": "{{allocation_id}}"
                }
              ]
            },
            "description": "Retrieve the storage allocation detail by performing a GET operation on the smart contract.  \nThe result of this will be important information we need such as the number of data and parity shards as well as the id and url of each blobber in the allocation, which is where our data is downloaded from."
          },
          "response": []
        },
        {
          "name": "2. Get metadata for file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "f7ae5dfd-0559-46a4-8bf4-8fe3e461e5f7",
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber0_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber0_id\"));"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "760a5a01-01d6-457b-bdaa-39dfcb5498db",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"path_hash\", response.path_hash)",
                  "    pm.globals.set(\"num_of_blocks_to_download\", response.num_of_blocks)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "009897bd-3f53-4acf-ab66-4a27628585f4",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber0_url}}/v1/file/meta/{{allocation_id}}"
          },
          "response": []
        },
        {
          "name": "3. Get latest read marker for first blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "cbe44cd3-8604-41f4-a016-1ceb680e54fe",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"latest_read_marker_current_counter\", response.counter)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "5b0428c0-d7e8-4d0a-9390-b662ab4a0746",
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_id\"));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "7104fc78-d6fb-4e70-a900-ce299bd492a1",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/:id/latestreadmarker?client={{wallet_id}}&blobber={{blobber0_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                ":id",
                "latestreadmarker"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                },
                {
                  "key": "blobber",
                  "value": "{{blobber0_id}}"
                }
              ],
              "variable": [
                {
                  "id": "0963e231-dee3-420d-ade8-14e48c1728a9",
                  "key": "id",
                  "value": "6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7",
                  "description": "(Required) The address of smart contract"
                }
              ]
            },
            "description": "The Read marker is another important feature of the network. \nIt ensures that every download is recorded, tallied and transparent.  \n\nEach blobber writes a read marker to the client's read pool when a file has been served.  \nThis ensures that blobbers are paid while keeping an audit.  \n\nThe read marker contains a counter of how many blocks have been read from the current blobber by the current pool, as well as the allocation  id the read was requested from.  \n\nAll Allocations use the same read pool.\n\nAt the point of download, a new read marker is written with an incremented counter"
          },
          "response": []
        },
        {
          "name": "4. Download EC shard from first blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "4cb32aeb-071d-48f1-b714-fa756895aba7",
                "exec": [
                  "pm.test(\"Response code is 200 and data returned\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var fail = false;",
                  "    try{",
                  "        pm.globals.set(\"latest_read_marker_current_counter\", pm.response.json().latest_rm.counter)",
                  "        fail = true;",
                  "    } catch(ignored){}",
                  "",
                  "    if(fail){",
                  "        pm.expect.fail(\"Download failed - latest write marker returned, use it in subsequent calculations\")",
                  "    }",
                  "",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "",
                  "    var downloaded_shards = pm.variables.get(\"downloaded_shards\")",
                  "    downloaded_shards = downloaded_shards == undefined ? \"\" : downloaded_shards",
                  "    downloaded_shards = downloaded_shards.split(\",\")",
                  "    ",
                  "    var index = downloaded_shards.indexOf(\"\");",
                  "    if (index !== -1) {",
                  "        downloaded_shards.splice(index, 1);",
                  "    }",
                  "    downloaded_shards.push(\"\\\"\" + responseBody + \"\\\"\")",
                  "    pm.globals.set(\"downloaded_shards\", downloaded_shards.join(\",\"))",
                  "",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "",
                  "    if(current_blobber_number >= num_data_shards){ ",
                  "        // once the correct number of shards have been downlaoded we have enough to resonstruct the file and do not need to download the remaining parity shards",
                  "        console.log(\"Blobbers have successfully been downloaded from, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "dba475bc-0474-48ee-80ff-32a1447ecd31",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "8ba282e0-1a14-4bab-8721-99d65b6507ac",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber0_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber0_url}}/v1/file/download/{{allocation_id}}",
            "description": "- Run this for as many data shards as you have\n- success will return raw data\n- failure will return latest write marker   \nTODO: Fill out rest"
          },
          "response": []
        },
        {
          "name": "5. Get latest read marker for second blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "899afd12-122e-4f74-8bd7-6a1476a3fc8b",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "    var response = JSON.parse(responseBody);",
                  "    pm.globals.set(\"latest_read_marker_current_counter\", response.counter)",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "97d39bff-6bd6-447c-80ad-2bc363d4dd5b",
                "exec": [
                  "var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "pm.globals.set(\"current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_url\"));",
                  "pm.globals.set(\"blobber_id_matching_current_blobber\", pm.variables.get(\"blobber\" + current_blobber_number + \"_id\"));"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "7f76f22e-9960-44af-b8ae-b4d61b88f0a9",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{test_case_sharder}}/v1/screst/:id/latestreadmarker?client={{wallet_id}}&blobber={{blobber1_id}}",
              "host": [
                "{{test_case_sharder}}"
              ],
              "path": [
                "v1",
                "screst",
                ":id",
                "latestreadmarker"
              ],
              "query": [
                {
                  "key": "client",
                  "value": "{{wallet_id}}"
                },
                {
                  "key": "blobber",
                  "value": "{{blobber1_id}}"
                }
              ],
              "variable": [
                {
                  "id": "0963e231-dee3-420d-ade8-14e48c1728a9",
                  "key": "id",
                  "value": "6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7",
                  "description": "(Required) The address of smart contract"
                }
              ]
            },
            "description": "The Read marker is another important feature of the network. \nIt ensures that every download is recorded, tallied and transparent.  \n\nEach blobber writes a read marker to the client's read pool when a file has been served.  \nThis ensures that blobbers are paid while keeping an audit.  \n\nThe read marker contains a counter of how many blocks have been read from the current blobber by the current pool, as well as the allocation  id the read was requested from.  \n\nAll Allocations use the same read pool.\n\nAt the point of download, a new read marker is written with an incremented counter"
          },
          "response": []
        },
        {
          "name": "4. Download EC shard from second blobber",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "9047dc05-62c3-4a86-8186-b981911035ff",
                "exec": [
                  "pm.test(\"Response code is 200 and data returned\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "",
                  "    var fail = false;",
                  "    try{",
                  "        pm.globals.set(\"latest_read_marker_current_counter\", pm.response.json().latest_rm.counter)",
                  "        fail = true;",
                  "    } catch(ignored){}",
                  "",
                  "    if(fail){",
                  "        pm.expect.fail(\"Download failed - latest write marker returned, use it in subsequent calculations\")",
                  "    }",
                  "",
                  "    var current_blobber_number = pm.variables.get(\"current_blobber_number\")",
                  "",
                  "    var downloaded_shards = pm.variables.get(\"downloaded_shards\")",
                  "    downloaded_shards = downloaded_shards == undefined ? \"\" : downloaded_shards",
                  "    downloaded_shards = downloaded_shards.split(\",\")",
                  "    ",
                  "    var index = downloaded_shards.indexOf(\"\");",
                  "    if (index !== -1) {",
                  "        downloaded_shards.splice(index, 1);",
                  "    }",
                  "    downloaded_shards.push(\"\\\"\" + responseBody + \"\\\"\")",
                  "    pm.globals.set(\"downloaded_shards\", downloaded_shards.join(\",\"))",
                  "",
                  "    current_blobber_number++;",
                  "",
                  "    var num_data_shards = pm.variables.get(\"num_data_shards\")",
                  "",
                  "    if(current_blobber_number >= num_data_shards){ ",
                  "        // once the correct number of shards have been downlaoded we have enough to resonstruct the file and do not need to download the remaining parity shards",
                  "        console.log(\"Blobbers have successfully been downloaded from, resetting to bloebber 0\")",
                  "        current_blobber_number = 0",
                  "    }",
                  "    pm.globals.set(\"current_blobber_number\", current_blobber_number)",
                  "});"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "abaa12e1-e9ef-4537-a21d-9275f096d2d2",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "    var num_blocks = parseInt(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"num_blocks\").value, pm.variables.toObject()))",
                  "    var latest_read_marker_current_counter = pm.variables.get(\"latest_read_marker_current_counter\")",
                  "    latest_read_marker_current_counter = parseInt(latest_read_marker_current_counter == undefined ? \"0\" : latest_read_marker_current_counter)",
                  "",
                  "    var read_marker_counter = latest_read_marker_current_counter + num_blocks",
                  "",
                  "    pm.globals.set(\"read_marker_counter\", read_marker_counter);",
                  "",
                  "    pm.globals.set(\"current_timestamp\", Math.round(Date.now() / 1000));",
                  "    var request_read_marker = JSON.parse(Property.replaceSubstitutions(pm.request.body.formdata.find(e => e.key == \"read_marker\").value, pm.variables.toObject()))",
                  "",
                  "",
                  "    var overallHashData = (",
                  "        (request_read_marker.allocation_id == undefined ? \"\" : request_read_marker.allocation_id) + \":\" +",
                  "        (request_read_marker.blobber_id == undefined ? \"\" : request_read_marker.blobber_id) + \":\" +",
                  "        (request_read_marker.client_id == undefined ? \"\" : request_read_marker.client_id) + \":\" +",
                  "        (request_read_marker.client_public_key == undefined ? \"\" : request_read_marker.client_public_key) + \":\" +",
                  "        (request_read_marker.owner_id == undefined ? \"\" : request_read_marker.owner_id) + \":\" +",
                  "        (request_read_marker.counter == undefined ? \"\" : request_read_marker.counter) + \":\" +",
                  "        (request_read_marker.timestamp == undefined ? \"\" : request_read_marker.timestamp)",
                  "    )",
                  "",
                  "",
                  "    var overallHash = await sha3256(overallHashData)",
                  "    pm.globals.set(\"hash_of_request_data\", overallHash);",
                  "    var mnemonic = pm.variables.get(\"mnemonic\")",
                  "    pm.globals.set(\"signature\", await sign(overallHash, mnemonic, \"0chain-client-split-key\"))",
                  "    clearTimeout(interval)",
                  "",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "8078e0c9-1620-40dd-b0e7-9265e67ee8c4",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path_hash",
                  "value": "{{path_hash}}",
                  "type": "text"
                },
                {
                  "key": "block_num",
                  "value": "1",
                  "type": "text"
                },
                {
                  "key": "num_blocks",
                  "value": "{{num_of_blocks_to_download}}",
                  "type": "text"
                },
                {
                  "key": "read_marker",
                  "value": "{\n    \"client_id\": \"{{wallet_id}}\",\n    \"client_public_key\": \"{{public_key}}\",\n    \"blobber_id\": \"{{blobber1_id}}\",\n    \"allocation_id\": \"{{allocation_id}}\",\n    \"owner_id\": \"{{wallet_id}}\",\n    \"timestamp\": {{current_timestamp}},\n    \"counter\": {{read_marker_counter}},\n    \"signature\": \"{{signature}}\"\n}",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber1_url}}/v1/file/download/{{allocation_id}}",
            "description": "- Run this for as many data shards as you have\n- success will return raw data\n- failure will return latest write marker   \nTODO: Fill out rest"
          },
          "response": []
        }
      ],
      "id": "f1d245da-2130-4a2d-9e06-683e4d9ae7e0",
      "description": "The following requests detail the downloading and re-assembly of shards into a single file.\n\nSteps 2, 3 and 4 need to be performed as a group n times where n is the number of data shards in the storage allocation.\n\neg.for an allocation with 2 data shards:  \nRun Step 1 then  \nfor blobber 1 -> [Run Steps 2, 3, 4] then   \nfor blobber 2 -> [Run Steps 2, 3, 4] then   \nRun step 5 to re-assemble the downloaded shards into a complete file.  \nPostman will switch to the next blobber and shard after the previous blobber has been downloaded from.\n\n\n# Requirements\n- Create a wallet\n- create an allocation\n- upload a file\n- lock read tokens",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "11872d8a-5610-41d5-81e9-1c0c0540d9ff",
            "type": "text/javascript",
            "exec": [
              ""
            ]
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "3f69d992-7acc-44a4-b20c-73a9437016ab",
            "type": "text/javascript",
            "exec": [
              "  if(pm.response.code != 200) {",
              "        postman.setNextRequest(\"1. Add a Collaborator\")",
              "    }"
            ]
          }
        }
      ]
    },
    {
      "name": "Share a file",
      "item": [
        {
          "name": "1. Add a Collaborator",
          "event": [
            {
              "listen": "test",
              "script": {
                "id": "f2d41029-d473-4a96-a2cf-6d10f7cc5deb",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  ""
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "id": "99a1b38f-3f86-4639-a0bd-a6d2efe03578",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "5a3f0164-c529-415f-8670-d1494ce9cd4f",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text"
                },
                {
                  "key": "collab_id",
                  "value": "4b4b520afcd703188d2915ca4c9b52c63fb14a73708e9b577aca73fbd34fd4df",
                  "type": "text"
                }
              ]
            },
            "url": "{{blobber1_url}}/v1/file/collaborator/{{allocation_id}}"
          },
          "response": []
        }
      ],
      "id": "e69f32c1-ed08-4bd2-b952-2aedfb052783",
      "description": "Files can be shared with other wallets on the 0chain network using 2 strategies:  \n- creating an auth ticket for a file or\n- Adding a collaborator to the file\n\nThe auth ticket contains information such as the content to be shared, who to share the content with (or indeed whether to share it with anyone), and how long to share it.  \nThe resultant JSON blob is Base-64 encoded for easy transport and can be used against many API endpoints directly, or using the 0box UI by navigating to \nhttps://{{network}}/0box/hash/{{auth_ticket}}\n\nAdding a collaborator to a file provides similar access to that file as an auth ticket for a given wallet without needing to supply the ticket itself.\n\n# Requirements\n**Sender:**\n- Create a wallet\n- create an allocation\n- upload a file  \n**Consumer:**\n- Create a wallet"
    },
    {
      "name": "Rename File",
      "item": [
        {
          "name": "1. Rename file",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "004dcb34-ac70-4bf2-af39-6fcbc2769631",
                "exec": [
                  "var Property = require('postman-collection').Property;",
                  "",
                  "async function main() {",
                  "    // postman boilerplate     ",
                  "    const interval = setTimeout(() => {}, 30000);",
                  "",
                  "   var allocationId = pm.variables.get(\"allocation_id\")",
                  "   var mnemonic = pm.variables.get(\"mnemonic\")",
                  "",
                  "    var allocationIdHash = await sha3256(allocationId)",
                  "    pm.globals.set(\"signature\", await sign(allocationIdHash, mnemonic, \"0chain-client-split-key\"))",
                  "",
                  "    clearTimeout(interval)",
                  "}",
                  "main()",
                  "",
                  "/*",
                  "Ensure your SHA3-256 impl uses the SHA3 standard, not keccak-256 (which is what CryptoJS uses)",
                  "*/",
                  "async function sha3256(data) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://api.hashify.net/hash/SHA3-256/hex?value=\" + data), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.Digest)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}",
                  "",
                  "/*",
                  "    This function is for illustration/testing purposes only.",
                  "    The API called within is not suitable for production calls and is provided without warranty.",
                  "*/",
                  "async function sign(data, mnemonics, passphrase) {",
                  "    return await new Promise((resolve, reject) => {",
                  "",
                  "        pm.sendRequest((\"https://example-0chain-crypto.herokuapp.com/sign?data=\" + data + \"&mnemonics=\" + mnemonics + \"&passphrase=\" + passphrase), function(err, response) {",
                  "",
                  "            var hashResponse = JSON.parse(response.text())",
                  "            resolve(hashResponse.hexString)",
                  "        });",
                  "    }).then(function(finalResult) {",
                  "        return finalResult;",
                  "    })",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "test",
              "script": {
                "id": "d03533de-a114-4655-acdb-8d5eedb4460a",
                "exec": [
                  "pm.test(\"Response code is 200\", function () {",
                  "    // retryOnFailure(200, 5)",
                  "    pm.expect(responseCode.code).to.eql(200);",
                  "});   ",
                  "",
                  "",
                  "// function retryOnFailure(successCode, numberOfRetrys) {",
                  "//     var key = request.name + '_counter';",
                  "//     var execCounter = postman.getEnvironmentVariable(key) || 1;",
                  "",
                  "//     var sleepDuration = 1000 * execCounter;",
                  "//     var waitUntilTime = new Date().getTime() + sleepDuration;",
                  "",
                  "//     if (responseCode.code !== successCode && execCounter <= numberOfRetrys) {",
                  "//         while (new Date().getTime() < waitUntilTime) {",
                  "//             // Do Nothing -> Wait",
                  "//         }",
                  "//         console.log('Retrying: ' + request.name + '\\nGot: ' + responseCode.code + ' Expected: ' + successCode + '\\nWaited: ' + sleepDuration / 1000 + 'sec  \\nRetry Number: ' + execCounter + ' of ' + numberOfRetrys);",
                  "//         execCounter++;",
                  "//         postman.setEnvironmentVariable(key, execCounter);",
                  "//         postman.setNextRequest(request.name);",
                  "//     }",
                  "// }",
                  ""
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "b9aa4288-03c2-4f21-9959-2731ea95c67b",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "multipart/form-data"
              },
              {
                "key": "X-App-Client-Key",
                "value": "{{public_key}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Id",
                "value": "{{wallet_id}}",
                "type": "text"
              },
              {
                "key": "X-App-Client-Signature",
                "value": "{{signature}}",
                "type": "text"
              }
            ],
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "connection_id",
                  "value": "{{blobber0_id}}",
                  "type": "text",
                  "description": "undefined"
                },
                {
                  "key": "path",
                  "value": "{{remote_filepath}}",
                  "type": "text",
                  "description": "undefined"
                },
                {
                  "key": "new_name",
                  "value": "/new_name",
                  "type": "text",
                  "description": "undefined"
                }
              ]
            },
            "url": "{{blobber1_url}}/v1/file/rename/{{allocation_id}}",
            "description": "To rename a file on 0chain's storage platform"
          },
          "response": []
        }
      ],
      "id": "ccdc4bcc-5365-4385-8853-b419e69ce669"
    },
    {
      "name": "Regressions Teardown",
      "item": [
        {
          "name": "1. Remove temporary variables",
          "event": [
            {
              "listen": "prerequest",
              "script": {
                "id": "00c66dbe-c102-41fe-958b-8eb25e599120",
                "exec": [
                  "const tempVars = [",
                  "    \"faucet_txn_hash\", ",
                  "    \"hash_of_request_data\",",
                  "    \"current_timestamp\",",
                  "    \"signature\",",
                  "    \"num_data_shards\",",
                  "    \"num_parity_shards\",",
                  "    \"blobber0_url\",",
                  "    \"blobber0_id\",",
                  "    \"blobber1_url\",",
                  "    \"blobber1_id\",",
                  "    \"blobber2_url\",",
                  "    \"blobber2_id\",",
                  "    \"local_filepath\",",
                  "    \"filename\",",
                  "    \"remote_filepath\",",
                  "    \"erasure_coding_example_api\",",
                  "    \"fileHash\",",
                  "    \"fileSize\",",
                  "    \"ec_shard_0\",",
                  "    \"ec_shard_1\",",
                  "    \"ec_shard_2\",",
                  "    \"current_blobber_number\",",
                  "    \"blobber_id_matching_current_blobber\",",
                  "    \"connection_id_for_current_blobber\",",
                  "    \"current_ec_shard\",",
                  "    \"uploadResponse\",",
                  "    \"referencePathResponseForCurrentBlobber\",",
                  "    \"newly_calculated_allocation_root\",",
                  "    \"prevAllocationRootForCurrentBlobber\",",
                  "    \"file_size\",",
                  "    \"read_pool_id\",",
                  "    \"downloaded_shards\",",
                  "    \"current_blobber\",",
                  "    \"path_hash\",",
                  "    \"num_of_blocks_to_download\",",
                  "    \"latest_read_marker_current_counter\",",
                  "    \"read_marker_counter\"",
                  "];",
                  "",
                  "tempVars.forEach((variableName) => {",
                  "    console.log(\"Deleteing temp variable [\" + variableName + \"] with value [\" + pm.globals.get(variableName) + \"]\")",
                  "    pm.globals.unset(variableName)",
                  "})"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "id": "a8cb9d6d-2927-499b-b63b-7897a2221870",
          "protocolProfileBehavior": {
            "disableBodyPruning": true
          },
          "request": {
            "method": "HEAD",
            "header": [],
            "url": {
              "raw": "https://{{network}}/dns/network?m=\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\"",
              "protocol": "https",
              "host": [
                "{{network}}"
              ],
              "path": [
                "dns",
                "network"
              ],
              "query": [
                {
                  "key": "m",
                  "value": "\"Postman requires this URL to be present in order to run the pre-request script, we don't care about the response\""
                }
              ]
            },
            "description": "Remove temporary variables created as part of the test suite. This makes reading the report page easier, but the values of the variables before deletion are logged below.  \n\nThe request URL is a dummy and can be ignored"
          },
          "response": []
        }
      ],
      "id": "b744da2f-b287-4dd0-8b89-7b04e99b0294"
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "id": "f2eb1645-caeb-4d1c-8f34-3a327f4e5af7",
        "type": "text/javascript",
        "exec": [
          "utils = {",
          "    delayTestUntilHttpCodeReceived: async function(pm, expectedResponse) {",
          "        const startTime = new Date().getTime()",
          "        console.log(\"Polling API for expected HTTP [\" + expectedResponse + \"] response before postman calls it and test cases execute...\")",
          "        var Property = require('postman-collection').Property;",
          "        var uri = Property.replaceSubstitutions(pm.request.url.toString(), pm.variables.toObject());",
          "        await attemptRequest(uri, expectedResponse)",
          "",
          "        async function attemptRequest(uri, expectedResponse, attempt = 1) {",
          "            const MAX_ATTEMPTS = 10;",
          "            if (attempt > MAX_ATTEMPTS) {",
          "                console.log(\"All polling attempts have been exhaused before an HTTP [\" + expectedResponse + \"] was received. Postman will now call the endpoint and therefore tests may fail.\")",
          "            } else {",
          "                pm.sendRequest(uri, async function(err, response) {",
          "                    if (err != null && response.code == null) {",
          "                        console.log(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an error [\" + err.code + \"] rather than the expected HTTP [\" + expectedResponse + \"]\")",
          "                        utils.sleep(1000)",
          "                        await attemptRequest(uri, expectedResponse, ++attempt)",
          "                    } else if (response.code != expectedResponse) {",
          "                        console.log(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an HTTP [\" + response.code + \"] rather than the expected [\" + expectedResponse + \"]\")",
          "                        utils.sleep(1000)",
          "                        await attemptRequest(uri, expectedResponse, ++attempt)",
          "                    } else {",
          "                        const elapsedTime = new Date().getTime() - startTime",
          "                        console.log(\"[\" + attempt + \"/\" + MAX_ATTEMPTS + \"] - Received an HTTP [\" + response.code + \"] as expected after [\" + elapsedTime + \"]ms\")",
          "                    }",
          "                });",
          "            }",
          "        }",
          "    },",
          "    sleep: function(millis) {",
          "        var waitUntil = new Date().getTime() + millis;",
          "        while (new Date().getTime() < waitUntil) {}",
          "    }",
          "}"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "id": "c8525f50-d2bd-4c70-b8f5-ccbc2d7e98b5",
        "type": "text/javascript",
        "exec": [
          "",
          "",
          ""
        ]
      }
    }
  ],
  "variable": [
    {
      "id": "ecdd5b5c-bc0b-452e-8558-a2bd28af80fd",
      "key": "upload-metadata",
      "value": "{ \"attributes\": {}, \"filename\": \"{{filename}}\", \"filepath\": \"{{remote_filepath}}\", \"actual_hash\": \"{{fileHash}}\", \"actual_size\": {{fileSize}}, \"connection_id\": \"{{connection_id_for_current_blobber}}\" }"
    },
    {
      "id": "606c9afd-4ab8-445c-9bfa-37e1913a4ec4",
      "key": "upload-request",
      "value": "--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"uploadFile\"; filename=\"{{filename}}\"\n\n{{current_ec_shard}}\n--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"connection_id\"\n\n{{connection_id_for_current_blobber}}\n--Xform_data_boundary_exampleX\nContent-Disposition: form-data; name=\"uploadMeta\"\n\n{{upload-metadata}}\n--Xform_data_boundary_exampleX--"
    }
  ]
}